14a15
> 
18c19
< #include "NamespaceHeader.H"
---
> #include "NamespaceHeader.H" 
64c65
< Real FokkerPlanck::computeDt(const KineticSpeciesPtrVect& a_soln, const int a_species, const int a_species_bkgr)
---
> Real FokkerPlanck::computeDt(const KineticSpeciesPtrVect& a_soln, const int a_species)
66c67
<   return TimeScale(a_soln, a_species, a_species_bkgr);
---
>   return TimeScale(a_soln, a_species);
86c87
< 
---
>   
103,104c104,105
<     const LevelData<FArrayBox>& pMapping    (a_global_dofs.data());
< 
---
>     const LevelData<FArrayBox>& pMapping    (a_global_dofs.data()); 
>   
159d159
<                                        //   const KineticSpecies&           a_species_bkgr,
164c164
<    * To ensure that the entries of the preconditioning matrix are correct, do the
---
>    * To ensure that the entries of the preconditioning matrix are correct, do the 
173c173
<    * Then, the preconditioning matrix assembled here will be the exact Jacobian, and
---
>    * Then, the preconditioning matrix assembled here will be the exact Jacobian, and 
178,212c178
<     if (m_time_implicit) {
< 
<       BandedMatrix *Pmat = (BandedMatrix*) a_P;
< 
<       const LevelData<FArrayBox>& soln_dfn    (a_species.distributionFunction());
<       const DisjointBoxLayout&    grids       (soln_dfn.disjointBoxLayout());
<       const PhaseGeom&            phase_geom  (a_species.phaseSpaceGeometry());
<       const int                   n_comp      (soln_dfn.nComp());
<       const VEL::VelCoordSys&     vel_coords  (phase_geom.velSpaceCoordSys());
<       const VEL::RealVect&        vel_dx      (vel_coords.dx());
<       //    const VEL::ProblemDomain&   vel_domain  = vel_coords.domain();
<       //    const VEL::Box&             domain_box  = vel_domain.domainBox();
<       const LevelData<FArrayBox>& pMapping    (a_global_dofs.data());
< 
<       //    const int nvpar = domain_box.size(0);
<       //    const int nmu   = domain_box.size(1);
< 
<       Real  dv = 1.0/vel_dx[0], dmu = 1.0/vel_dx[1], dv_sq = dv*dv, dmu_sq = dmu*dmu;
< 
<       DataIterator dit = grids.dataIterator();
<       for (dit.begin(); dit.ok(); ++dit) {
<         const Box& grid = grids[dit];
<         const FArrayBox& pMap = pMapping[dit];
< 
<         /* grid size */
<         IntVect bigEnd   = grid.bigEnd(),
<                 smallEnd = grid.smallEnd();
<         IntVect gridSize(bigEnd); gridSize -= smallEnd; gridSize += 1;
< 
<         FArrayBox *Dv, *Dmu, *Dvv, *Dmumu, *Dvmu;
<         Dv    = m_coeffs.D_v[dit].dataPtr();
<         Dmu   = m_coeffs.D_mu[dit].dataPtr();
<         Dvv   = m_coeffs.D_vv[dit].dataPtr();
<         Dmumu = m_coeffs.D_mumu[dit].dataPtr();
<         Dvmu  = m_coeffs.D_vmu[dit].dataPtr();
---
>   if (m_time_implicit) {
214c180,268
<         FArrayBox *Dv_F0, *Dmu_F0, *Dvv_F0, *Dmumu_F0, *Dvmu_F0;
---
>     BandedMatrix *Pmat = (BandedMatrix*) a_P;
>   
>     const LevelData<FArrayBox>& soln_dfn    (a_species.distributionFunction());
>     const DisjointBoxLayout&    grids       (soln_dfn.disjointBoxLayout());
>     const PhaseGeom&            phase_geom  (a_species.phaseSpaceGeometry());
>     const int                   n_comp      (soln_dfn.nComp());
>     const VEL::VelCoordSys&     vel_coords  (phase_geom.velSpaceCoordSys());
>     const VEL::RealVect&        vel_dx      (vel_coords.dx());
>     //    const VEL::ProblemDomain&   vel_domain  = vel_coords.domain();
>     //    const VEL::Box&             domain_box  = vel_domain.domainBox();
>     const LevelData<FArrayBox>& pMapping    (a_global_dofs.data()); 
>   
>     //    const int nvpar = domain_box.size(0);
>     //    const int nmu   = domain_box.size(1);
>   
>     Real  dv = 1.0/vel_dx[0], dmu = 1.0/vel_dx[1], dv_sq = dv*dv, dmu_sq = dmu*dmu;
>   
>     DataIterator dit = grids.dataIterator();
>     for (dit.begin(); dit.ok(); ++dit) {
>       const Box& grid = grids[dit];
>       const FArrayBox& pMap = pMapping[dit];
>   
>       /* grid size */
>       IntVect bigEnd   = grid.bigEnd(),
>               smallEnd = grid.smallEnd();
>       IntVect gridSize(bigEnd); gridSize -= smallEnd; gridSize += 1;
>   
>       FArrayBox *Dv, *Dmu, *Dvv, *Dmumu, *Dvmu;
>       Dv    = m_coeffs.D_v[dit].dataPtr();
>       Dmu   = m_coeffs.D_mu[dit].dataPtr();
>       Dvv   = m_coeffs.D_vv[dit].dataPtr();
>       Dmumu = m_coeffs.D_mumu[dit].dataPtr();
>       Dvmu  = m_coeffs.D_vmu[dit].dataPtr();
>   
>       FArrayBox *Dv_F0, *Dmu_F0, *Dvv_F0, *Dmumu_F0, *Dvmu_F0;
>       if (m_subtract_background) {
>         Dv_F0    = m_coeffs_F0.D_v[dit].dataPtr();
>         Dmu_F0   = m_coeffs_F0.D_mu[dit].dataPtr();
>         Dvv_F0   = m_coeffs_F0.D_vv[dit].dataPtr();
>         Dmumu_F0 = m_coeffs_F0.D_mumu[dit].dataPtr();
>         Dvmu_F0  = m_coeffs_F0.D_vmu[dit].dataPtr();
>       } else {
>         Dv_F0 = Dmu_F0 = Dvv_F0 = Dmumu_F0 = Dvmu_F0 = NULL;
>       }
>   
>       BoxIterator bit(grid);
>       for (bit.begin(); bit.ok(); ++bit) {
>         /* this point */
>         IntVect ic = bit();
>         /* neighboring points */
>         IntVect ie(ic);
>         IntVect iw(ic);
>         IntVect in(ic);
>         IntVect is(ic);
>         IntVect ine(ic);
>         IntVect inw(ic);
>         IntVect ise(ic);
>         IntVect isw(ic);
>         /* north-south is along mu; east-west is along v|| */
>         ie[_VPAR_DIM_]++;                     /* east  */
>         iw[_VPAR_DIM_]--;                     /* west  */
>         in[_MU_DIM_]++;                       /* north */
>         is[_MU_DIM_]--;                       /* south */
>         ine[_VPAR_DIM_]++; ine[_MU_DIM_]++;   /* northeast */
>         inw[_VPAR_DIM_]--; inw[_MU_DIM_]++;   /* northwest */
>         ise[_VPAR_DIM_]++; ise[_MU_DIM_]--;   /* southeast */
>         isw[_VPAR_DIM_]--; isw[_MU_DIM_]--;   /* southwest */
>   
>         Real DvL, DvR, DmuL, DmuR, DvvL, DvvR, DmumuL, DmumuR;
>         Real DvmuWS, DvmuES, DvmuWN, DvmuEN;
>   
>         DvL  = Dv->get(ic,0);
>         DvR  = Dv->get(ie,0);
>         DmuL = Dmu->get(ic,0);
>         DmuR = Dmu->get(in,0);
>   
>         DvvL   = Dvv->get(ic,0);
>         DvvR   = Dvv->get(ie,0);
>         DmumuL = Dmumu->get(ic,0);
>         DmumuR = Dmumu->get(in,0);
>   
>         DvmuWS = Dvmu->get(ic ,0);
>         DvmuES = Dvmu->get(ie ,0);
>         DvmuWN = Dvmu->get(in ,0);
>         DvmuEN = Dvmu->get(ine,0);
>   
>         Real DvL_F0, DvR_F0, DmuL_F0, DmuR_F0, DvvL_F0, DvvR_F0, DmumuL_F0, DmumuR_F0;
>         Real DvmuWS_F0, DvmuES_F0, DvmuWN_F0, DvmuEN_F0;
>   
216,220c270,283
<           Dv_F0    = m_coeffs_F0.D_v[dit].dataPtr();
<           Dmu_F0   = m_coeffs_F0.D_mu[dit].dataPtr();
<           Dvv_F0   = m_coeffs_F0.D_vv[dit].dataPtr();
<           Dmumu_F0 = m_coeffs_F0.D_mumu[dit].dataPtr();
<           Dvmu_F0  = m_coeffs_F0.D_vmu[dit].dataPtr();
---
>           DvL_F0  = Dv_F0->get(ic,0);
>           DvR_F0  = Dv_F0->get(ie,0);
>           DmuL_F0 = Dmu_F0->get(ic,0);
>           DmuR_F0 = Dmu_F0->get(in,0);
>   
>           DvvL_F0   = Dvv_F0->get(ic,0);
>           DvvR_F0   = Dvv_F0->get(ie,0);
>           DmumuL_F0 = Dmumu_F0->get(ic,0);
>           DmumuR_F0 = Dmumu_F0->get(in,0);
>   
>           DvmuWS_F0 = Dvmu_F0->get(ic ,0);
>           DvmuES_F0 = Dvmu_F0->get(ie ,0);
>           DvmuWN_F0 = Dvmu_F0->get(in ,0);
>           DvmuEN_F0 = Dvmu_F0->get(ine,0);
222c285,298
<           Dv_F0 = Dmu_F0 = Dvv_F0 = Dmumu_F0 = Dvmu_F0 = NULL;
---
>           DvL_F0  = 0.0;
>           DvR_F0  = 0.0;
>           DmuL_F0 = 0.0;
>           DmuR_F0 = 0.0;
>   
>           DvvL_F0   = 0.0;
>           DvvR_F0   = 0.0;
>           DmumuL_F0 = 0.0;
>           DmumuR_F0 = 0.0;
>   
>           DvmuWS_F0 = 0.0;
>           DvmuES_F0 = 0.0;
>           DvmuWN_F0 = 0.0;
>           DvmuEN_F0 = 0.0;
224,283c300,335
< 
<         BoxIterator bit(grid);
<         for (bit.begin(); bit.ok(); ++bit) {
<           /* this point */
<           IntVect ic = bit();
<           /* neighboring points */
<           IntVect ie(ic);
<           IntVect iw(ic);
<           IntVect in(ic);
<           IntVect is(ic);
<           IntVect ine(ic);
<           IntVect inw(ic);
<           IntVect ise(ic);
<           IntVect isw(ic);
<           /* north-south is along mu; east-west is along v|| */
<           ie[_VPAR_DIM_]++;                     /* east  */
<           iw[_VPAR_DIM_]--;                     /* west  */
<           in[_MU_DIM_]++;                       /* north */
<           is[_MU_DIM_]--;                       /* south */
<           ine[_VPAR_DIM_]++; ine[_MU_DIM_]++;   /* northeast */
<           inw[_VPAR_DIM_]--; inw[_MU_DIM_]++;   /* northwest */
<           ise[_VPAR_DIM_]++; ise[_MU_DIM_]--;   /* southeast */
<           isw[_VPAR_DIM_]--; isw[_MU_DIM_]--;   /* southwest */
< 
<           Real DvL, DvR, DmuL, DmuR, DvvL, DvvR, DmumuL, DmumuR;
<           Real DvmuWS, DvmuES, DvmuWN, DvmuEN;
< 
<           DvL  = Dv->get(ic,0);
<           DvR  = Dv->get(ie,0);
<           DmuL = Dmu->get(ic,0);
<           DmuR = Dmu->get(in,0);
< 
<           DvvL   = Dvv->get(ic,0);
<           DvvR   = Dvv->get(ie,0);
<           DmumuL = Dmumu->get(ic,0);
<           DmumuR = Dmumu->get(in,0);
< 
<           DvmuWS = Dvmu->get(ic ,0);
<           DvmuES = Dvmu->get(ie ,0);
<           DvmuWN = Dvmu->get(in ,0);
<           DvmuEN = Dvmu->get(ine,0);
< 
<           Real DvL_F0, DvR_F0, DmuL_F0, DmuR_F0, DvvL_F0, DvvR_F0, DmumuL_F0, DmumuR_F0;
<           Real DvmuWS_F0, DvmuES_F0, DvmuWN_F0, DvmuEN_F0;
< 
<           if (m_subtract_background) {
<             DvL_F0  = Dv_F0->get(ic,0);
<             DvR_F0  = Dv_F0->get(ie,0);
<             DmuL_F0 = Dmu_F0->get(ic,0);
<             DmuR_F0 = Dmu_F0->get(in,0);
< 
<             DvvL_F0   = Dvv_F0->get(ic,0);
<             DvvR_F0   = Dvv_F0->get(ie,0);
<             DmumuL_F0 = Dmumu_F0->get(ic,0);
<             DmumuR_F0 = Dmumu_F0->get(in,0);
< 
<             DvmuWS_F0 = Dvmu_F0->get(ic ,0);
<             DvmuES_F0 = Dvmu_F0->get(ie ,0);
<             DvmuWN_F0 = Dvmu_F0->get(in ,0);
<             DvmuEN_F0 = Dvmu_F0->get(ine,0);
---
>   
>         for (int n(0); n < n_comp; n++) {
>           /* global row/column numbers */
>           int pc, pe, pw, pn, ps, pne, pnw, pse, psw;//, pee, pww, pnn, pss;
>           pc  = (int) pMap.get(ic ,n);
>           pn  = (int) pMap.get(in ,n);
>           ps  = (int) pMap.get(is ,n);
>           pe  = (int) pMap.get(ie ,n);
>           pw  = (int) pMap.get(iw ,n);
>           pne = (int) pMap.get(ine,n);
>           pnw = (int) pMap.get(inw,n);
>           pse = (int) pMap.get(ise,n);
>           psw = (int) pMap.get(isw,n);
>   
>           /* coefficients */
>           Real nu = (m_fixed_cls_freq ? m_cls_freq : m_cls_norm);
>   
>           Real ac = 0;
>           Real an = 0;
>           Real as = 0;
>           Real ae = 0;
>           Real aw = 0;
>           Real ane = 0;
>           Real anw = 0;
>           Real ase = 0;
>           Real asw = 0;
>           
>           /* Advection terms along vpar */
>           if ((DvL < 0.0) && (DvR < 0.0)) {
>             ac += nu * DvR * dv;
>             aw -= nu * DvL * dv;
>           } else if ((DvL >= 0.0) && (DvR < 0.0)) {
>             ac += nu * (DvR - DvL) * dv;
>           } else if ((DvL < 0.0) && (DvR >= 0.0)) {
>             ae += nu * DvR * dv;
>             aw -= nu * DvL * dv;
285,335c337,348
<             DvL_F0  = 0.0;
<             DvR_F0  = 0.0;
<             DmuL_F0 = 0.0;
<             DmuR_F0 = 0.0;
< 
<             DvvL_F0   = 0.0;
<             DvvR_F0   = 0.0;
<             DmumuL_F0 = 0.0;
<             DmumuR_F0 = 0.0;
< 
<             DvmuWS_F0 = 0.0;
<             DvmuES_F0 = 0.0;
<             DvmuWN_F0 = 0.0;
<             DvmuEN_F0 = 0.0;
<           }
< 
<           for (int n(0); n < n_comp; n++) {
<             /* global row/column numbers */
<             int pc, pe, pw, pn, ps, pne, pnw, pse, psw;//, pee, pww, pnn, pss;
<             pc  = (int) pMap.get(ic ,n);
<             pn  = (int) pMap.get(in ,n);
<             ps  = (int) pMap.get(is ,n);
<             pe  = (int) pMap.get(ie ,n);
<             pw  = (int) pMap.get(iw ,n);
<             pne = (int) pMap.get(ine,n);
<             pnw = (int) pMap.get(inw,n);
<             pse = (int) pMap.get(ise,n);
<             psw = (int) pMap.get(isw,n);
< 
<             /* coefficients */
<             Real nu = (m_fixed_cls_freq ? m_cls_freq : m_cls_norm);
< 
<             Real ac = 0;
<             Real an = 0;
<             Real as = 0;
<             Real ae = 0;
<             Real aw = 0;
<             Real ane = 0;
<             Real anw = 0;
<             Real ase = 0;
<             Real asw = 0;
< 
<             /* Advection terms along vpar */
<             if ((DvL < 0.0) && (DvR < 0.0)) {
<               ac += nu * DvR * dv;
<               aw -= nu * DvL * dv;
<             } else if ((DvL >= 0.0) && (DvR < 0.0)) {
<               ac += nu * (DvR - DvL) * dv;
<             } else if ((DvL < 0.0) && (DvR >= 0.0)) {
<               ae += nu * DvR * dv;
<               aw -= nu * DvL * dv;
---
>             ae += nu * DvR * dv;
>             ac -= nu * DvL * dv;
>           }
>           if (m_subtract_background) {
>             if ((DvL_F0 < 0.0) && (DvR_F0 < 0.0)) {
>               ac += nu * DvR_F0 * dv;
>               aw -= nu * DvL_F0 * dv;
>             } else if ((DvL_F0 >= 0.0) && (DvR_F0 < 0.0)) {
>               ac += nu * (DvR_F0 - DvL_F0) * dv;
>             } else if ((DvL_F0 < 0.0) && (DvR_F0 >= 0.0)) {
>               ae += nu * DvR_F0 * dv;
>               aw -= nu * DvL_F0 * dv;
337,352c350,351
<               ae += nu * DvR * dv;
<               ac -= nu * DvL * dv;
<             }
<             if (m_subtract_background) {
<               if ((DvL_F0 < 0.0) && (DvR_F0 < 0.0)) {
<                 ac += nu * DvR_F0 * dv;
<                 aw -= nu * DvL_F0 * dv;
<               } else if ((DvL_F0 >= 0.0) && (DvR_F0 < 0.0)) {
<                 ac += nu * (DvR_F0 - DvL_F0) * dv;
<               } else if ((DvL_F0 < 0.0) && (DvR_F0 >= 0.0)) {
<                 ae += nu * DvR_F0 * dv;
<                 aw -= nu * DvL_F0 * dv;
<               } else {
<                 ae += nu * DvR_F0 * dv;
<                 ac -= nu * DvL_F0 * dv;
<               }
---
>               ae += nu * DvR_F0 * dv;
>               ac -= nu * DvL_F0 * dv;
354,363c353,376
< 
<             /* Advection terms along mu */
<             if ((DmuL < 0.0) && (DmuR < 0.0)) {
<               ac += 2.0 * nu * DmuR * dmu;
<               as -= 2.0 * nu * DmuL * dmu;
<             } else if ((DmuL >= 0.0) && (DmuR < 0.0)) {
<               ac += 2.0 * nu * (DmuR - DmuL) * dmu;
<             } else if ((DmuL < 0.0) && (DmuR >= 0.0)) {
<               an += 2.0 * nu * DmuR * dmu;
<               as -= 2.0 * nu * DmuL * dmu;
---
>           }
>           
>           /* Advection terms along mu */
>           if ((DmuL < 0.0) && (DmuR < 0.0)) {
>             ac += 2.0 * nu * DmuR * dmu;
>             as -= 2.0 * nu * DmuL * dmu;
>           } else if ((DmuL >= 0.0) && (DmuR < 0.0)) {
>             ac += 2.0 * nu * (DmuR - DmuL) * dmu;
>           } else if ((DmuL < 0.0) && (DmuR >= 0.0)) {
>             an += 2.0 * nu * DmuR * dmu;
>             as -= 2.0 * nu * DmuL * dmu;
>           } else {
>             an += 2.0 * nu * DmuR * dmu;
>             ac -= 2.0 * nu * DmuL * dmu;
>           }
>           if (m_subtract_background) {
>             if ((DmuL_F0 < 0.0) && (DmuR_F0 < 0.0)) {
>               ac += 2.0 * nu * DmuR_F0 * dmu;
>               as -= 2.0 * nu * DmuL_F0 * dmu;
>             } else if ((DmuL_F0 >= 0.0) && (DmuR_F0 < 0.0)) {
>               ac += 2.0 * nu * (DmuR_F0 - DmuL_F0) * dmu;
>             } else if ((DmuL_F0 < 0.0) && (DmuR_F0 >= 0.0)) {
>               an += 2.0 * nu * DmuR_F0 * dmu;
>               as -= 2.0 * nu * DmuL_F0 * dmu;
365,400c378,379
<               an += 2.0 * nu * DmuR * dmu;
<               ac -= 2.0 * nu * DmuL * dmu;
<             }
<             if (m_subtract_background) {
<               if ((DmuL_F0 < 0.0) && (DmuR_F0 < 0.0)) {
<                 ac += 2.0 * nu * DmuR_F0 * dmu;
<                 as -= 2.0 * nu * DmuL_F0 * dmu;
<               } else if ((DmuL_F0 >= 0.0) && (DmuR_F0 < 0.0)) {
<                 ac += 2.0 * nu * (DmuR_F0 - DmuL_F0) * dmu;
<               } else if ((DmuL_F0 < 0.0) && (DmuR_F0 >= 0.0)) {
<                 an += 2.0 * nu * DmuR_F0 * dmu;
<                 as -= 2.0 * nu * DmuL_F0 * dmu;
<               } else {
<                 an += 2.0 * nu * DmuR_F0 * dmu;
<                 ac -= 2.0 * nu * DmuL_F0 * dmu;
<               }
<             }
< 
<             /* Laplacian term along vpar */
<             ae += nu * DvvR * dv_sq;
<             aw += nu * DvvL * dv_sq;
<             ac -= nu * (DvvR + DvvL) * dv_sq;
<             if (m_subtract_background) {
<               ae += nu * DvvR_F0 * dv_sq;
<               aw += nu * DvvL_F0 * dv_sq;
<               ac -= nu * (DvvR_F0 + DvvL_F0) * dv_sq;
<             }
< 
<             /* Laplacian term along mu */
<             an += 4.0 * nu * DmumuR * dmu_sq;
<             as += 4.0 * nu * DmumuL * dmu_sq;
<             ac -= 4.0 * nu * (DmumuR + DmumuL) * dmu_sq;
<             if (m_subtract_background) {
<               an += 4.0 * nu * DmumuR_F0 * dmu_sq;
<               as += 4.0 * nu * DmumuL_F0 * dmu_sq;
<               ac -= 4.0 * nu * (DmumuR_F0 + DmumuL_F0) * dmu_sq;
---
>               an += 2.0 * nu * DmuR_F0 * dmu;
>               ac -= 2.0 * nu * DmuL_F0 * dmu;
402,453c381,471
< 
<             /* Cross term 1: d/dv(Dvmu df/dmu) */
<             ac  += 0.5 * nu * dv * dmu * (DvmuES - DvmuEN - DvmuWS + DvmuWN);
<             ae  += 0.5 * nu * dv * dmu * (DvmuES - DvmuEN);
<             aw  += 0.5 * nu * dv * dmu * (-DvmuWS + DvmuWN);
<             an  += 0.5 * nu * dv * dmu * (DvmuEN - DvmuWN);
<             as  += 0.5 * nu * dv * dmu * (-DvmuES + DvmuWS);
<             asw += 0.5 * nu * dv * dmu * (DvmuWS);
<             ase += 0.5 * nu * dv * dmu * (-DvmuES);
<             anw += 0.5 * nu * dv * dmu * (-DvmuWN);
<             ane += 0.5 * nu * dv * dmu * (DvmuEN);
<             if (m_subtract_background) {
<               ac  += 0.5 * nu * dv * dmu * (DvmuES_F0 - DvmuEN_F0 - DvmuWS_F0 + DvmuWN_F0);
<               ae  += 0.5 * nu * dv * dmu * (DvmuES_F0 - DvmuEN_F0);
<               aw  += 0.5 * nu * dv * dmu * (-DvmuWS_F0 + DvmuWN_F0);
<               an  += 0.5 * nu * dv * dmu * (DvmuEN_F0 - DvmuWN_F0);
<               as  += 0.5 * nu * dv * dmu * (-DvmuES_F0 + DvmuWS_F0);
<               asw += 0.5 * nu * dv * dmu * (DvmuWS_F0);
<               ase += 0.5 * nu * dv * dmu * (-DvmuES_F0);
<               anw += 0.5 * nu * dv * dmu * (-DvmuWN_F0);
<               ane += 0.5 * nu * dv * dmu * (DvmuEN_F0);
<             }
< 
<             /* Cross term 2: d/dmu(Dvmu df/dv) */
<             ac  += 0.5 * nu * dv * dmu * (DvmuWN - DvmuEN - DvmuWS + DvmuES);
<             ae  += 0.5 * nu * dv * dmu * (DvmuEN - DvmuES);
<             aw  += 0.5 * nu * dv * dmu * (-DvmuWN + DvmuWS);
<             an  += 0.5 * nu * dv * dmu * (DvmuWN - DvmuEN);
<             as  += 0.5 * nu * dv * dmu * (-DvmuWS + DvmuES);
<             asw += 0.5 * nu * dv * dmu * (DvmuWS);
<             ase += 0.5 * nu * dv * dmu * (-DvmuES);
<             anw += 0.5 * nu * dv * dmu * (-DvmuWN);
<             ane += 0.5 * nu * dv * dmu * (DvmuEN);
<             if (m_subtract_background) {
<               ac  += 0.5 * nu * dv * dmu * (DvmuWN_F0 - DvmuEN_F0 - DvmuWS_F0 + DvmuES_F0);
<               ae  += 0.5 * nu * dv * dmu * (DvmuEN_F0 - DvmuES_F0);
<               aw  += 0.5 * nu * dv * dmu * (-DvmuWN_F0 + DvmuWS_F0);
<               an  += 0.5 * nu * dv * dmu * (DvmuWN_F0 - DvmuEN_F0);
<               as  += 0.5 * nu * dv * dmu * (-DvmuWS_F0 + DvmuES_F0);
<               asw += 0.5 * nu * dv * dmu * (DvmuWS_F0);
<               ase += 0.5 * nu * dv * dmu * (-DvmuES_F0);
<               anw += 0.5 * nu * dv * dmu * (-DvmuWN_F0);
<               ane += 0.5 * nu * dv * dmu * (DvmuEN_F0);
<             }
< 
<             int  ncols = m_nbands, ix = 0;
<             int  *icols = (int*)  calloc (ncols,sizeof(int));
<             Real *data  = (Real*) calloc (ncols,sizeof(Real));
< 
<             /* center element */
<             icols[ix] = pc;
<             data[ix] = a_shift - ac;
---
>           }
>   
>           /* Laplacian term along vpar */
>           ae += nu * DvvR * dv_sq;
>           aw += nu * DvvL * dv_sq;
>           ac -= nu * (DvvR + DvvL) * dv_sq;
>           if (m_subtract_background) {
>             ae += nu * DvvR_F0 * dv_sq;
>             aw += nu * DvvL_F0 * dv_sq;
>             ac -= nu * (DvvR_F0 + DvvL_F0) * dv_sq;
>           }
>           
>           /* Laplacian term along mu */
>           an += 4.0 * nu * DmumuR * dmu_sq;
>           as += 4.0 * nu * DmumuL * dmu_sq;
>           ac -= 4.0 * nu * (DmumuR + DmumuL) * dmu_sq;
>           if (m_subtract_background) {
>             an += 4.0 * nu * DmumuR_F0 * dmu_sq;
>             as += 4.0 * nu * DmumuL_F0 * dmu_sq;
>             ac -= 4.0 * nu * (DmumuR_F0 + DmumuL_F0) * dmu_sq;
>           }
>   
>           /* Cross term 1: d/dv(Dvmu df/dmu) */
>           ac  += 0.5 * nu * dv * dmu * (DvmuES - DvmuEN - DvmuWS + DvmuWN);
>           ae  += 0.5 * nu * dv * dmu * (DvmuES - DvmuEN);
>           aw  += 0.5 * nu * dv * dmu * (-DvmuWS + DvmuWN);
>           an  += 0.5 * nu * dv * dmu * (DvmuEN - DvmuWN);
>           as  += 0.5 * nu * dv * dmu * (-DvmuES + DvmuWS);
>           asw += 0.5 * nu * dv * dmu * (DvmuWS);
>           ase += 0.5 * nu * dv * dmu * (-DvmuES);
>           anw += 0.5 * nu * dv * dmu * (-DvmuWN);
>           ane += 0.5 * nu * dv * dmu * (DvmuEN);
>           if (m_subtract_background) {
>             ac  += 0.5 * nu * dv * dmu * (DvmuES_F0 - DvmuEN_F0 - DvmuWS_F0 + DvmuWN_F0);
>             ae  += 0.5 * nu * dv * dmu * (DvmuES_F0 - DvmuEN_F0);
>             aw  += 0.5 * nu * dv * dmu * (-DvmuWS_F0 + DvmuWN_F0);
>             an  += 0.5 * nu * dv * dmu * (DvmuEN_F0 - DvmuWN_F0);
>             as  += 0.5 * nu * dv * dmu * (-DvmuES_F0 + DvmuWS_F0);
>             asw += 0.5 * nu * dv * dmu * (DvmuWS_F0);
>             ase += 0.5 * nu * dv * dmu * (-DvmuES_F0);
>             anw += 0.5 * nu * dv * dmu * (-DvmuWN_F0);
>             ane += 0.5 * nu * dv * dmu * (DvmuEN_F0);
>           }
>   
>           /* Cross term 2: d/dmu(Dvmu df/dv) */
>           ac  += 0.5 * nu * dv * dmu * (DvmuWN - DvmuEN - DvmuWS + DvmuES);
>           ae  += 0.5 * nu * dv * dmu * (DvmuEN - DvmuES);
>           aw  += 0.5 * nu * dv * dmu * (-DvmuWN + DvmuWS);
>           an  += 0.5 * nu * dv * dmu * (DvmuWN - DvmuEN);
>           as  += 0.5 * nu * dv * dmu * (-DvmuWS + DvmuES);
>           asw += 0.5 * nu * dv * dmu * (DvmuWS);
>           ase += 0.5 * nu * dv * dmu * (-DvmuES);
>           anw += 0.5 * nu * dv * dmu * (-DvmuWN);
>           ane += 0.5 * nu * dv * dmu * (DvmuEN);
>           if (m_subtract_background) {
>             ac  += 0.5 * nu * dv * dmu * (DvmuWN_F0 - DvmuEN_F0 - DvmuWS_F0 + DvmuES_F0);
>             ae  += 0.5 * nu * dv * dmu * (DvmuEN_F0 - DvmuES_F0);
>             aw  += 0.5 * nu * dv * dmu * (-DvmuWN_F0 + DvmuWS_F0);
>             an  += 0.5 * nu * dv * dmu * (DvmuWN_F0 - DvmuEN_F0);
>             as  += 0.5 * nu * dv * dmu * (-DvmuWS_F0 + DvmuES_F0);
>             asw += 0.5 * nu * dv * dmu * (DvmuWS_F0);
>             ase += 0.5 * nu * dv * dmu * (-DvmuES_F0);
>             anw += 0.5 * nu * dv * dmu * (-DvmuWN_F0);
>             ane += 0.5 * nu * dv * dmu * (DvmuEN_F0);
>           }
>           
>           int  ncols = m_nbands, ix = 0;
>           int  *icols = (int*)  calloc (ncols,sizeof(int));
>           Real *data  = (Real*) calloc (ncols,sizeof(Real));
>   
>           /* center element */
>           icols[ix] = pc; 
>           data[ix] = a_shift - ac;
>           ix++;
>   
>           /* east element */
>           if (pe >= 0) {
>             icols[ix] = pe;
>             data[ix] = -ae;
>             ix++;
>           }
>           /* west element */
>           if (pw >= 0) {
>             icols[ix] = pw;
>             data[ix] = -aw;
>             ix++;
>           }
>           /* north element */
>           if (pn >= 0) {
>             icols[ix] = pn;
>             data[ix] = -an;
455,509d472
< 
<             /* east element */
<             if (pe >= 0) {
<               icols[ix] = pe;
<               data[ix] = -ae;
<               ix++;
<             }
<             /* west element */
<             if (pw >= 0) {
<               icols[ix] = pw;
<               data[ix] = -aw;
<               ix++;
<             }
<             /* north element */
<             if (pn >= 0) {
<               icols[ix] = pn;
<               data[ix] = -an;
<               ix++;
<             }
<             /* south element */
<             if (ps >= 0) {
<               icols[ix] = ps;
<               data[ix] = -as;
<               ix++;
<             }
<             /* north east element */
<             if (pne >= 0) {
<               icols[ix] = pne;
<               data[ix] = -ane;
<               ix++;
<             }
<             /* north west element */
<             if (pnw >= 0) {
<               icols[ix] = pnw;
<               data[ix] = -anw;
<               ix++;
<             }
<             /* south east element */
<             if (pse >= 0) {
<               icols[ix] = pse;
<               data[ix] = -ase;
<               ix++;
<             }
<             /* south west element */
<             if (psw >= 0) {
<               icols[ix] = psw;
<               data[ix] = -asw;
<               ix++;
<             }
< 
<             CH_assert(ix <= m_nbands);
<             CH_assert(ix <= Pmat->getNBands());
<             Pmat->setRowValues(pc,ix,icols,data);
<             free(data);
<             free(icols);
510a474,509
>           /* south element */
>           if (ps >= 0) {
>             icols[ix] = ps;
>             data[ix] = -as;
>             ix++;
>           }
>           /* north east element */
>           if (pne >= 0) {
>             icols[ix] = pne;
>             data[ix] = -ane;
>             ix++;
>           }
>           /* north west element */
>           if (pnw >= 0) {
>             icols[ix] = pnw;
>             data[ix] = -anw;
>             ix++;
>           }
>           /* south east element */
>           if (pse >= 0) {
>             icols[ix] = pse;
>             data[ix] = -ase;
>             ix++;
>           }
>           /* south west element */
>           if (psw >= 0) {
>             icols[ix] = psw;
>             data[ix] = -asw;
>             ix++;
>           }
>   
>           CH_assert(ix <= m_nbands);
>           CH_assert(ix <= Pmat->getNBands());
>           Pmat->setRowValues(pc,ix,icols,data);
>           free(data);
>           free(icols);
514d512
<     return;
515a514,515
>   return;
> }
517,519c517,518
< void FokkerPlanck::preTimeStep( const KineticSpeciesPtrVect& a_soln_mapped,
<                                 const int a_species_a,
<                                 const int a_species_b,
---
> void FokkerPlanck::preTimeStep( const KineticSpeciesPtrVect& a_soln_mapped, 
>                                 const int a_species, 
522,585c521,528
< {
<   //static bool first_call = true;
<   if(m_subtract_background){
< 
<        if(!m_compute_maxwellian){
< 	  if(!m_F0_a.isDefined()){
<    	   const KineticSpecies& soln_species_a(*(a_soln_physical[a_species_a]));
<    	   const PhaseGeom&      phase_geom_a(soln_species_a.phaseSpaceGeometry());
<    	   m_F0_a.define( phase_geom_a.gridsFull(), 1, IntVect::Zero );
< 
< 
< 	   KineticSpeciesPtr ref_species_a( soln_species_a.clone( IntVect::Unit, false ) );
<      	   m_ref_func_a->assign( *ref_species_a, a_time );
<      	   LevelData<FArrayBox>& ref_dfn_a( ref_species_a->distributionFunction() );
<            for (DataIterator dit(m_F0_a.dataIterator()); dit.ok(); ++dit) {
<              m_F0_a[dit].copy(ref_dfn_a[dit]);
<            }
<            convertToCellCenters(phase_geom_a, m_F0_a);
< 	  }
<        } else{
< 	  if(!m_F0_a.isDefined()){
< 	   const KineticSpecies& soln_species_a(*(a_soln_physical[a_species_a]));
<    	   const PhaseGeom&      phase_geom_a(soln_species_a.phaseSpaceGeometry());
<    	   m_F0_a.define( phase_geom_a.gridsFull(), 1, IntVect::Zero );
< 	  }
< 	 computeReferenceSolution( a_soln_physical,m_F0_a, a_species_a, a_time);
<        }
< 
< 
<       if(!m_compute_maxwellian){
< 	  if(!m_F0_b.isDefined()){
<    	   const KineticSpecies& soln_species_b(*(a_soln_physical[a_species_b]));
<    	   const PhaseGeom&      phase_geom_b(soln_species_b.phaseSpaceGeometry());
<    	   m_F0_b.define( phase_geom_b.gridsFull(), 1, IntVect::Zero );
< 
< 
< 	   KineticSpeciesPtr ref_species_b( soln_species_b.clone( IntVect::Unit, false ) );
<      	   m_ref_func_b->assign( *ref_species_b, a_time );
<      	   LevelData<FArrayBox>& ref_dfn_b( ref_species_b->distributionFunction() );
<            for (DataIterator dit(m_F0_b.dataIterator()); dit.ok(); ++dit) {
<              m_F0_b[dit].copy(ref_dfn_b[dit]);
<            }
<            convertToCellCenters(phase_geom_b, m_F0_b);
<            m_ref_updated = true;
< 	  } else{
< 	     m_ref_updated=false;
< 	  }
< 
<        } else{
< 	  if(!m_F0_b.isDefined()){
< 	   const KineticSpecies& soln_species_b(*(a_soln_physical[a_species_b]));
<    	   const PhaseGeom&      phase_geom_b(soln_species_b.phaseSpaceGeometry());
<    	   m_F0_b.define( phase_geom_b.gridsFull(), 1, IntVect::Zero );
< 	  }
< 	  computeReferenceSolution( a_soln_physical,m_F0_b, a_species_b, a_time);
< 	  m_ref_updated = true;
<        }
<   }
< 
<   const KineticSpecies& soln_species_m_a(*(a_soln_mapped[a_species_a]));
<   const PhaseGeom&      phase_geom(soln_species_m_a.phaseSpaceGeometry());
<   const CFG::MagGeom&   mag_geom(phase_geom.magGeom());
< 
<   if (!m_fp_kinetic_energy.isDefined()) {
---
> { 
>   static bool first_call = true;
>   computeReferenceSolution  ( a_soln_physical, a_species, a_time);
> 
>   if (first_call) {
>     const KineticSpecies& soln_species(*(a_soln_mapped[a_species]));
>     const PhaseGeom&      phase_geom(soln_species.phaseSpaceGeometry());
>     const CFG::MagGeom&   mag_geom(phase_geom.magGeom());
591,594d533
<   }
< 
<   if(!m_energy_cons.isDefined()){
< 
600,609c539,548
< 
<   const KineticSpecies&       soln_species_m_b(*(a_soln_mapped[a_species_b]));
<   const LevelData<FArrayBox>& soln_dfn_m_b(soln_species_m_b.distributionFunction());
<   const DisjointBoxLayout&    grids_m_b(soln_dfn_m_b.getBoxes());
<   const PhaseGeom&          phase_geom_m_b(soln_species_m_b.phaseSpaceGeometry());
<   const RefCountedPtr<PhaseGeom>& phase_geom_ptr_bkgr(soln_species_m_b.phaseSpaceGeometryPtr());
<   const int                   n_comp_m_b(soln_dfn_m_b.nComp());
<   LevelData<FArrayBox> dfn_m_b(grids_m_b,n_comp_m_b,IntVect::Zero);
<   for (DataIterator dit(dfn_m_b.dataIterator()); dit.ok(); ++dit) {
<     dfn_m_b[dit].copy(soln_dfn_m_b[dit]);
---
>   
>   const KineticSpecies&       soln_species(*(a_soln_mapped[a_species]));
>   const LevelData<FArrayBox>& soln_dfn(soln_species.distributionFunction());
>   const DisjointBoxLayout&    grids(soln_dfn.getBoxes());
>   const PhaseGeom&            phase_geom(soln_species.phaseSpaceGeometry());
>   const int                   n_comp(soln_dfn.nComp());
>     
>   LevelData<FArrayBox> dfn(grids,n_comp,IntVect::Zero);
>   for (DataIterator dit(dfn.dataIterator()); dit.ok(); ++dit) {
>     dfn[dit].copy(soln_dfn[dit]);
611,612c550
<   convertToCellCenters(phase_geom_m_b,dfn_m_b);
< 
---
>   convertToCellCenters(phase_geom,dfn);
613a552
>   const RefCountedPtr<PhaseGeom>& phase_geom_ptr(soln_species.phaseSpaceGeometryPtr());
615c554
<   computePotentialsAndCoeffs( soln_species_m_a,soln_species_m_b, dfn_m_b, grids_m_b, phase_geom_ptr_bkgr);
---
>   computePotentialsAndCoeffs( soln_species, dfn, grids, phase_geom_ptr); 
618c557
<  // first_call = false;
---
>   first_call = false;
622c561
< void FokkerPlanck::evalRosenbluthPotentials( LevelData<FArrayBox>&        a_phi,
---
> void FokkerPlanck::evalRosenbluthPotentials( LevelData<FArrayBox>&            a_phi,
624,625c563,564
<                                              const LevelData<FArrayBox>&  a_dfn,
<                                              const double                 a_mass ) const
---
>                                              const LevelData<FArrayBox>&      a_dfn,
>                                              const double                     a_mass ) const 
630c569
<    //Create temporary phi_one and phi_two
---
>    //Create temporary phi_one and phi_two 
639,640c578,579
<    //Calculate Rosenbluth Potentials
<    RosenbluthPotentials RosenbluthPotentials(phi_one, phi_two, a_dfn, a_phase_geom,
---
>    //Calculate Rosenbluth Potentials 
>    RosenbluthPotentials RosenbluthPotentials(phi_one, phi_two, a_dfn, a_phase_geom, 
651,652c590
<                                   const double                a_charge,
< 				  const double 		      a_charge_bkgr	) const
---
>                                   const double                a_charge ) const
662c600
<     //Fundamental constants
---
>     //Fundamental constants  
672,675c610,613
< 
<     //Compute collisional normalization
<     double Coulomb_Lg = 23 - log( sqrt(2.0) * pow(a_charge,3) * sqrt(N)/1000.0 / pow(T, 3.0/2.0) );
<     a_cls_norm = F * tau * Coulomb_Lg * pow(a_charge * ech, 2) *pow(a_charge_bkgr*ech,2)/ pow( a_mass * Mkg * eps0, 2);
---
>     
>     //Compute collisional normalization 
>     double Coulomb_Lg = 23 - log( sqrt(2.0) * pow(a_charge,3) * sqrt(N)/1000.0 / pow(T, 3.0/2.0) ); 
>     a_cls_norm = F * tau * Coulomb_Lg * pow(a_charge * ech, 4) / pow( a_mass * Mkg * eps0, 2);
698,706d635
< 
<     if (!m_compute_maxwellian) {
<       KineticFunctionLibrary* library = KineticFunctionLibrary::getInstance();
<       std::string function_name;
<       a_ppcls.query( "ref_function_a", function_name );
<       m_ref_func_a = library->find( function_name );
<       a_ppcls.query( "ref_function_b", function_name );
<       m_ref_func_b = library->find( function_name );
<     }
707a637,640
>   KineticFunctionLibrary* library = KineticFunctionLibrary::getInstance();
>   std::string function_name;
>   a_ppcls.query( "ref_function", function_name );
>   m_ref_func = library->find( function_name );
724,728c657,658
<       std::cout << "  Reference Function for species a:" << std::endl;
<       m_ref_func_a->printParameters();
<       std::cout << "  Reference Function for background species:" << std::endl;
<       m_ref_func_b->printParameters();
< 
---
>       std::cout << "  Reference Function:" << std::endl;
>       m_ref_func->printParameters();
850c780
< 
---
>       
872c802
< 
---
>       
894c824
< 
---
>       
916c846
< 
---
>       
978a909
> 
1000c931
< 
---
>       
1022c953
< 
---
>       
1044c975
< 
---
>       
1066c997
< 
---
>      
1133c1064
< 
---
>       
1155c1086
< 
---
>       
1177c1108
< 
---
>       
1199c1130
< 
---
>      
1210d1140
< 
1212,1213c1142
< 					                                  LevelData<FArrayBox>& a_F0,
< 					                                  const int a_species,
---
>                                             const int a_species,
1216c1145
<   //static bool first_call = true;
---
>   static bool first_call = true;
1219a1149,1153
>   if (first_call) {
>     m_F0.define( phase_geom.gridsFull(), 1, IntVect::Zero );
>   }
> 
>   if (m_compute_maxwellian) {
1223c1157
< 
---
>   
1226c1160
< 
---
>   
1229c1163
< 
---
>   
1235c1169
< 
---
>   
1239c1173
< 
---
>   
1241,1243c1175,1181
<     maxwellian.eval(a_F0,soln_species);
<     phase_geom.multJonValid(a_F0);
<     convertToCellCenters(phase_geom, a_F0);
---
>     maxwellian.eval(m_F0,soln_species);
>     phase_geom.multJonValid(m_F0);
>     convertToCellCenters(phase_geom, m_F0);
> 
>     m_ref_updated = true;
> 
>   } else {
1244a1183,1203
>     /* use the specified reference distribution function */
>     if (first_call) {
> 
>       KineticSpeciesPtr ref_species( soln_species.clone( IntVect::Unit, false ) );
>       m_ref_func->assign( *ref_species, a_time );
>       LevelData<FArrayBox>& ref_dfn( ref_species->distributionFunction() );
>       for (DataIterator dit(m_F0.dataIterator()); dit.ok(); ++dit) {
>         m_F0[dit].copy(ref_dfn[dit]);
>       }
>       convertToCellCenters(phase_geom, m_F0);
>       m_ref_updated = true;
> 
>     } else {
> 
>       m_ref_updated = false;
> 
>     }
> 
>   }
> 
>   first_call = false;
1376,1379c1335,1337
< void FokkerPlanck::computePotentialsAndCoeffs(const KineticSpecies&         a_species,
< 					                                    const KineticSpecies&	        a_species_bkgr,
<                                               const LevelData<FArrayBox>&   a_dfn,
<                                               const DisjointBoxLayout&      a_grids,
---
> void FokkerPlanck::computePotentialsAndCoeffs(const KineticSpecies&            a_species, 
>                                               const LevelData<FArrayBox>&      a_dfn,
>                                               const DisjointBoxLayout&         a_grids,
1382c1340
<   //static bool first_call = true;
---
>   static bool first_call = true;
1386c1344
<   const double mass_fp = a_species_bkgr.mass();
---
>   const double mass_fp = a_species.mass();
1388c1346
<   if (m_first_call_pc) {
---
>   if (first_call) {
1390c1348
<     computeClsNorm(m_cls_norm, a_species.mass(), a_species.charge(),a_species_bkgr.charge());
---
>     computeClsNorm(m_cls_norm, a_species.mass(), a_species.charge());
1415c1373
< 
---
>     
1421c1379
< 
---
>     
1442c1400
<   if ((m_update_freq < 0) || (m_it_counter % m_update_freq == 0) || m_first_call_pc) {
---
>   if ((m_update_freq < 0) || (m_it_counter % m_update_freq == 0) || first_call) {
1449c1407
<         delta_f[dit].minus(m_F0_b[dit]);
---
>         delta_f[dit].minus(m_F0[dit]);
1451c1409,1410
<       if (m_ref_updated || m_first_call_pc) {
---
> 
>       if (m_ref_updated || first_call) {
1456c1415
<         evalRosenbluthPotentials(m_phi_F0, a_phase_geom, m_F0_b, mass_fp);
---
>         evalRosenbluthPotentials(m_phi_F0, a_phase_geom, m_F0, mass_tp);
1460c1419,1420
<       evalRosenbluthPotentials(m_phi, a_phase_geom, delta_f, mass_fp);
---
> 
>       evalRosenbluthPotentials(m_phi, a_phase_geom, delta_f, mass_tp);
1465c1425
<       evalRosenbluthPotentials(m_phi, a_phase_geom, a_dfn, mass_fp);
---
>       evalRosenbluthPotentials(m_phi, a_phase_geom, a_dfn, mass_tp);
1472c1432
<   m_first_call_pc = false;
---
>   first_call = false;
1479c1439
< 					    const LevelData<FArrayBox>& a_dfn,
---
>                                             const LevelData<FArrayBox>& a_dfn,
1611c1571
< 
---
>     
1618c1578
< 
---
>       
1625c1585
< 
---
>     
1627c1587
< 
---
>     
1645,1651d1604
< /*void FokkerPlanck::disableEnergyConservationFactor()
< {
<   for (CFG::DataIterator dit(m_energy_cons.dataIterator()); dit.ok(); ++dit) {
<     m_energy_cons[dit].setVal(1.0);
<   }
< }*/
< 
1693d1645
<                                 const int                     a_species_bkgr,
1696,1701c1648,1651
<   const KineticSpecies&       soln_species(*(a_soln[a_species]));
<   const LevelData<FArrayBox>& soln_dfn(soln_species.distributionFunction());
< 
< 
<   const DisjointBoxLayout&    grids(soln_dfn.getBoxes());
<   const PhaseGeom&            phase_geom(soln_species.phaseSpaceGeometry());
---
>   const KineticSpecies&           soln_species(*(a_soln[a_species]));
>   const LevelData<FArrayBox>&     soln_dfn(soln_species.distributionFunction());
>   const DisjointBoxLayout&        grids(soln_dfn.getBoxes());
>   const PhaseGeom&                phase_geom(soln_species.phaseSpaceGeometry());
1703c1653
<   const int                   n_comp(soln_dfn.nComp());
---
>   const int                       n_comp(soln_dfn.nComp());
1711d1660
< 
1713,1729c1662
<     const KineticSpecies&	soln_species_bkgr(*(a_soln[a_species_bkgr]));
<     const LevelData<FArrayBox>& soln_dfn_bkgr(soln_species_bkgr.distributionFunction());
< 
< 
<     const DisjointBoxLayout&    grids_bkgr(soln_dfn_bkgr.getBoxes());
<     const PhaseGeom&            phase_geom_bkgr(soln_species_bkgr.phaseSpaceGeometry());
<     const RefCountedPtr<PhaseGeom>& phase_geom_ptr_bkgr(soln_species_bkgr.phaseSpaceGeometryPtr());
<     const int                   n_comp_bkgr(soln_dfn_bkgr.nComp());
< 
<     LevelData<FArrayBox> dfn_bkgr(grids_bkgr,n_comp_bkgr,IntVect::Zero);
<     for (DataIterator dit(dfn_bkgr.dataIterator()); dit.ok(); ++dit) {
<       dfn_bkgr[dit].copy(soln_dfn_bkgr[dit]);
<     }
<     convertToCellCenters(phase_geom_bkgr,dfn_bkgr);
< 
<     computePotentialsAndCoeffs(soln_species,soln_species_bkgr, dfn_bkgr, grids_bkgr, phase_geom_ptr_bkgr);
< 
---
>     computePotentialsAndCoeffs(soln_species, dfn, grids, phase_geom_ptr);
1744,1745d1676
< 
< 
1749c1680
<       delta_f[dit].minus(m_F0_a[dit]);
---
>       delta_f[dit].minus(m_F0[dit]);
1768c1699
<     computeFokkerPlanckFlux(tmp_flux_vpar, tmp_flux_mu, m_coeffs, m_F0_a, phase_geom);
---
>     computeFokkerPlanckFlux(tmp_flux_vpar, tmp_flux_mu, m_coeffs, m_F0, phase_geom);
1781,1782c1712,1713
< 
<     computeFokkerPlanckFlux(fp_flux_vpar, fp_flux_mu, m_coeffs, dfn ,phase_geom);
---
>     
>     computeFokkerPlanckFlux(fp_flux_vpar, fp_flux_mu, m_coeffs, dfn, phase_geom);
1805,1806c1736
< 
< Real FokkerPlanck::TimeScale(const KineticSpeciesPtrVect& a_soln, const int a_species,const int a_species_bkgr)
---
> Real FokkerPlanck::TimeScale(const KineticSpeciesPtrVect& a_soln, const int a_species)
